---

layout : single
title : "Reversecore chap 7 - 스택 프레임"
categories : [Reversing]
tags : [reversecore, unsolved]
comment : true

---

### '리버싱 핵심 원리'의 내용 및 이슈들과 해결책을 다룹니다.


---

<br/>

### 스택

프로세스에서 스택 메모리의 역할은 아래와 같다.<br/><br/>

**A.** 함수 내의 로컬 변수 임시 저장<br/>
**B.** 함수 호출 시 파라미터 전달<br/>
**C.** 복귀 주소(return address)저장<br/><br/>

프로세스에서 스택 포인터(ESP)의 초기 값은 Stack Bottom쪽(그림 아래쪽)에 가깝다. PUSH 명령으로 스택에 값을 입력하면 스택 포인터(ESP)는 감소하고, POP 명령으로 스택에서 값을 꺼내면 스택포인터는 증가한다. **즉, 스택은 거꾸로 자란다!** <br/>


![7-1](https://user-images.githubusercontent.com/26838115/44967182-6038b480-af7a-11e8-803e-d8a44e70a6f2.jpg)


1. POP EBP 를 하면 EBP 값이 변하는데, PUSH 의 경우에는 PUSH EBP 명령어를 실행해도, 현재의 EBP 값(예: 0019FF38) 값만 메모리에 저장되지 EBP 자체의 값은 바뀌지 않는다.

2. POP EBP 명령어는 맨 위에 저장된  stack위의 메모리(EBP 값이 저장된)를 한 개 보내 버리는 동시에, EBP 값을 저장되었던 값으로 바꾸어 버린다.

3. RETN 명령어는 POP처럼 스택 위의 메모리를 하나 날려 버린다!

4. 스택 프레임은 ESP(스택 포인터)가 아닌 EBP(베이스 포인터) 레지스터를 사용하여 스택 내의 로컬 변수, 파라미터, 복귀 주소에 접근하는 기법을 말한다.

5. 스택 프레임을 쓸 때 특정 함수를 CALL 할 때, **PUSH EBP / MOV EBP, ESP** 명령어를 이용해 스택 포인터 값을 베이스 포인터 값에 대입한다! 함수 본체에서는 ESP가 변경 되더라도 EBP가 변경되지 않으므로 안전하게 로컬 변수와 파라미터를 엑세스할 수 있다!

6. 예를 들어, C에서 작성된 add (a, b) 함수 속으로 들어간다고 가정했을 때, 로컬 변수의 스택 영역을 확보하기 위해, **SUB ESP, 8** 을 이용할 수 있다. 즉, 8바이트 공간을 로컬 변수 2개 저장을 위해 안전하게 잡아 놓는 것이다.

7. 해당 함수에서 볼 일(?)이 다 끝났을 경우, **MOV ESP, EBP** 명령어를 이용해서 ESP를 함수를 시작했을 때의 값으로 복원시키고, **POP EBP** 명령어를 이용해 저장된 EBP 값을 불러옴으로써, 특정 함수에 들어가기 전의 EBP 값을 복구한다.  **RETN** 명령어를 통해 함수를 마무리하고, 함수가 CALL 되기 이전의 함수로 복귀한다.

8. ***5~7***의 해당 명령어들은 호출된(**CALL**) 함수 내부에서 이루어지는 작업이다.

9. ***6***의 경우처럼, 변수 2개를 위한 공간을 따로 잡았을 경우 **ADD ESP, 8** 명령어를 통해 8바이트 공간을 메꾸어 버릴 수 있다. 앞서 따로 뺴 놓은 8바이트 공간은 해당 함수의 로컬 변수를 저장하는데 쓰였으므로, 함수에서 빠져나온 시점에서부터는 의미가 없기 때문이다.



<br/>


---



### Issue #1

해결해야 할 이슈 : 

- 로컬 변수 저장을 위해 예제에서는 해당하는 명령어를 사용한다.

00401006 | MOV EAX,DWORD PTR SS:[EBP+8] | ; [EBP+8] = param a
|:--------|:--------|:--------|
00401009 | MOV DWORD PTR SS:[EBP-8], EAX | ; [EBP-8] = local x
0040100C | MOV ECX,DWORD PTR SS:[EBP+C] | ; [EBP+C] = param b
0040100F | MOV DWORD PTR SS:[EBP-4], ECX | ; [EBP-4] = local y

로 되어 있는데, 

앞의 두 줄의 경우 

00401012 | MOV DWORD PTR SS:[EBP-8], DWORD PTR SS:[EBP+8] | 
|:--------|:--------|:--------|
-> 즉, param a 를 local x로 바로 대입시키기  ||

같은 방식은 안되는 걸까?

이 경우, RAM과 RAM 사이에 (stack에 저장된 값을 레지스터를 거치지 않고 바로 스택에 대입) 연산은 불가능한 것인지, 아니면 다른 이유가 있는 것인지?

이유를 찾아보자.


---

### Issue #1 solution :

일단, '리버싱 엔지니어링 바이블'에 의하면, 레지스터를 거쳐서 연산을 해야 한다고 나와 있다. (명확한 설명은 없음)





















