---

layout : single
title : "Reversecore Issue chap 3 - 리틀 엔디언 표기법"
categories : [Reversing]
tags : [reversecore]
comment : true

---

### '리버싱 핵심 원리'의 내용 및 이슈들과 해결책을 다룹니다.

---

<br/>


1. **바이트 오더링** : <br/>

	바이트 오더링은 데이터를 저장하는 방식이라고 기억하면 된다. 크게 두 가지로,  **빅 엔디언(Big Endian)**과 **리틀 엔디언(Little Endian)**방식이 있다!

	TYPE | Name | SIZE | 데이터 | 빅 엔디언 Style | 리틀 엔디언 Style
	|:----|:----|:----|:----|:----|:-----|
	BYTE | b | 1 | 0x12; | [12] | [12]
	WORD | w | 2 | 0x1234; | [12][34] | [34][12]
	DWORD | dw | 4 | 0x12345678 | [12][34][56][78] | [78][56][34][12]
	char [] | str | 6 | "abcde"; | [61][62][63][64][65][00] | [61][62][63][64][65][00]

	바이트(BYTE) 타입의 b변수를 저장할 때는 두 방식의 차이가 없다. 하지만 2바이트 이상의 크기를 가진 자료형을 저장할 때부터 차이가 나타난다!<br/>
	빅 엔디언 방식은 데이터를 저장할 때 사람이 보는 방식과 동일하게 앞에서부터 순차적으로 저장한다. 하지만 리틀 엔디언 방식은 데이터를 저장할 때 역순으로 저장한다(2바이트 혹은 4바이트 자료형과 같이 멀티바이트(multi-bytes)인 경우). <br/>
	str 문자열은 Endian 형식에 상관없이 동일하다. 문자열은 결국 캐릭터(char) 배열이기 때문에, 각 바이트를 하나씩 연속해서 저장한다고 생각해보면 리틀 엔디언에서도 문자열 자체는 빅 엔디언과 동일한 순서로 저장됨을 이해할 수 있다.

2. 빅 엔디언의 장점

빅 엔디언은 사용자가 보는 순서대로 저장해서 메모리를 파악하기가 편하다는 장점이 있다.




<br/>

---



### Issue #1

해결해야 할 이슈 : 

