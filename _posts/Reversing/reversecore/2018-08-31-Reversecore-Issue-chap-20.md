---

layout : single
title : "Reversecore chap 20 - 인라인 패치 실습"
categories : [Reversing]
tags : [reversecore]
comment : true

---

### '리버싱 핵심 원리'의 내용 및 이슈들과 해결책을 다룹니다.

---

<br/>


실행 압축되거나 암호화된 파일을 패치할 때 자주 사용되는 인라인 패치(Inline Patch) 기법을 실습해 보자.


---

### 인라인 패치

인라인 코드 패치(Inline Code Patch) 혹은 줄여서 인라인 패치(Inline Patch)라고 하는 기법은 원하는 코드를 직접 수정하기 어려울 때 간단히 코드 케이브(Code Cave)라고 하는 패치 코드를 삽입한 후 실행해 프로그램을 패치시키는 기법이다. 주로 대상 프로그램이 실행 압축(혹은 암호화)되어 있어서 파일을 직접 수정하기 어려운 경우 많이 사용하는 기법이다.


![i1](https://user-images.githubusercontent.com/26838115/45533031-3a8c9480-b831-11e8-814b-6f2702d2ef96.png)

위 그림처럼 전형적인 실행 압축(또는 암호화) 코드가 있다고 해 보자. EP(Entry Point)코드는 암호화된 OEP(Original Entry Point) 코드를 복호화한 후 OEP 코드로 점프한다. 만약 우리가 패치하길 원하는 코드가 암호화된 OEP 영역에 존재한다면(위치를 알고 있다고 하더라도) 그냥은 패치시키기 어렵다. 복호화 과정에서 엉뚱하게 복호화되기 때문이다.

위와 같은 문제를 해결하기 위해, 코드 케이브라고 하는 별도의 패치 코드를 설치한 후 EP 코드의 복호화 과정 이후 JMP 명령어를 수정하여 코드 케이브가 실행되도록 한다. 그리고 코드 케이브 내에 패치 코드를 실행 후(이미 OEP는 복호화되었기 때문에 그대로 수정 가능) OEP로 가면 된다. 즉 실행될 때마다 (별도의 패치 코드를 실행해) 매번 프로세스 메모리의 코드를 패치하기 때문에 이러한 패치 기법을 인라인 코드 패치(혹은 인라인 패치)라고 부르는 것이다. 이것이 바로 일반적인 코드 패치 방법과 다른 점이다.

  | 코드 패치 | 인라인 패치
|:-----|:-----|:----|
대상 | 파일 | 파일 & 메모리
횟수 | 1번 | 파일에는 1번만, 메모리는 실행될 때마다
방법 | Direct(원하는 위치에 직접 패치) | Indirect (코드 케이브를 미리 설치한 후 메모리에서 원하는 영역이 복호화되었을 때 패치)


---

### 트레이싱해보기

디버깅을 하다 보면 아래 그림의 코드를 만나게 된다.

![1](https://user-images.githubusercontent.com/26838115/45538170-38323680-b841-11e8-9774-2c0aa7cbaec2.png)

그 중 401046 주소에 있는 Checksum 계산 루프를 보자. 먼저 401041 주소의 MOV EDX, 0 명령으로 EDX에 0을 대입(초기화)한다. 그리고 401046 주소의 ADD 명령으로 특정 주소 영역(4010F5 ~ 401248)에서 4바이트 단위로 순차적으로 값을 읽어들여서 EDX 레지스터에 덧셈 연산으로 누적시킨다.

루프를 종료하면 EDX 레지스터에는 특정한 값이 저장된다. 이 값이 바로 Checksum 값이며, 이 Checksum 계산 영역은 이중으로 암호화되어 있는 영역이라고 추측할 수 있다. 바로 이 영역에 패치해야 하는 문자열이 존재하는 것이다.

> 4바이트 크기를 가지는 EDX 레지스터에 이처럼 4바이트 값을 계속 더해나가다 보면 overflow가 발생한다. 일반적인 Checksum 계산은 이러한 overflow는 무시하고 최종적으로 EDX에 남아 있는 값을 사용한다.

401062 ~ 401068 주소의 CMP/JE 명령은 이렇게 계산한 Checksum(EDX 레지스터에 저장된) 값이 31EB8DB0)와 같다면(코드가 변조되지 않았다면), 401083 주소의 JMP 명령어에 의해서 OEP(40121E)로 간다. 하지만 Checksum 값이 다르다면 에러 메시지("CRC of this file has been modified !!!")를 출력하고 프로그램이 종료된다.

이러한 Checksum 계산 방법은 특정 영역의 코드/데이터가 변조되지 않았음을 검증하는 용도로 많이 사용된다. 해당 영역 내에서 한 바이트만 변경되어도 Checksum 값이 달라지기 때문이다. 따라서 해당 영역의 코드/데이터를 변경하고 싶다면 관련 Checksum 비교 부분도 수정해야 한다.


<br/>

---

### 해결해야 할 문제:


### Issue #1:

실습예제가 책에 소개된 내용과 달라 따라가기가 힘들다. 일단 기법 내용을 읽었으니 다시 패치해봐야 함.

---


### Issue #2: 

OllyDbg assemble 과정에서, Label expected라는 것만 뜨고 어셈블이 안되는데... 찾아봐도 해결책이 나오지 않는다.

![2](https://user-images.githubusercontent.com/26838115/45544924-aa137b80-b853-11e8-8c48-8f5360f24be1.png)

[Stackoverflow에 질문을 올려놓았다.](https://stackoverflow.com/questions/52330225/ollydbg-label-expected-issue)





















